// homework_mo_3.2.1.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
// Вторая задаче из третьей лекции модуля Многопоточность.

//For_each

//Реализуйте параллельный вариант оператора for_each.
//Функция должна принимать итераторы на начало и конец контейнера и ссылку, обрабатывающую функцию.
//При реализации нужно рекурсивно разделить контейнер на несколько блоков и для каждого запустить отдельную задачу, применяющую обрабатывающую функцию к части контейнера.

// я хочу реализовать простейший цикл, в которому к каждому элементу прибавляется десятка, чтобы как-то отличать,
// какие элементы прошли через цикл, а какие не прошли. 

#include <iostream>
#include <thread>
#include <future>
#include <algorithm>
#include <array>
#include <numeric>
#include <vector>


template<typename It, typename T, size_t size = 1>
T para_for_each(It begin, It end, T init)
{
    // считаем длину интервала, в данном случае должно получиться шесть
    auto curr_size = std::distance(begin, end);
    // если наш интервал равен единичке, то есть он самый маленький, то просто возвращаем число, на которое показывает итератор begin плюс десятка. 
    

    if (curr_size <= size)
    {
        // мне нужно вернуть такой результат - если значение size равно 1, то нужно вернуть значение элемента вектора по номеру size, к которому прибавлено число 10
        // не получется вернуть такой результат
        // например, вот такая фраза не работает, не получается вывести первый элемент данного интервала плюс 10
        
        //auto iter{ v.begin() }; 
        //return *iter + 10;
        
        // фраза на строке 40 это просто чтобы программа работала
        return 10;
    }
    // если иначе, то есть интервал больше единицы, то делим его пополам
    auto mid = begin;
    // мы ходим получить здесь итератор, который показывает середину интервала
    // функция advance сдвинула наш итератор вперёд, на середину оставшегося интервала. 
    // сейчас он на начало показывает, а чтобы он показал на середину, нужно текущий интервал разделить пополам
    std::advance(mid, curr_size / 2);
    // левую часть интервала будем считать в асинхронной задаче ft_res
    // левая часть от начала до середины.
    auto ft_res = std::async(para_for_each<It, T>, begin, mid, init);
    // для левой части вызываем рекурсивно функцию от середины до конца
    auto lf_res = para_for_each(mid, end, init);

    // выходим из рекурсии, вызвав результат будущего
    return ft_res.get() + 10;
}
int main()
{
    std::cout << "Hello World!\n";

    std::vector<int> V(6,2);
    std::cout << "The elements are: " << std::endl;
    for ( int i = 0; i < 5; i++)
    std::cout << V[i] << std::endl;
    std::cout << "The changed elements are: " << std::endl;
    //std::for_each(std::begin(arr), std::end(arr), Foo);
    std::cout << para_for_each(V.begin(), V.end(), 0) << std::endl;


    return 0;
}

